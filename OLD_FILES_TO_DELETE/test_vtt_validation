"""
VTT Validation Test - Validates ACTUAL VTT output against raw transcript
This test parses real VTT files and checks for missing/added words
"""

import unittest
import re
from typing import List, Dict, Tuple
from difflib import SequenceMatcher


class VTTParser:
    """Parse VTT files and extract text"""
    
    @staticmethod
    def parse_vtt(vtt_content: str) -> List[Dict]:
        """Parse VTT content into segments"""
        segments = []
        
        # Split by double newline to get cue blocks
        blocks = vtt_content.split('\n\n')
        
        for block in blocks:
            if '-->' not in block:
                continue
            
            lines = block.strip().split('\n')
            if len(lines) < 2:
                continue
            
            # First line is timestamp
            timestamp_line = None
            text_lines = []
            
            for line in lines:
                if '-->' in line:
                    timestamp_line = line
                elif line.strip() and not line.startswith('WEBVTT'):
                    text_lines.append(line.strip())
            
            if timestamp_line and text_lines:
                # Extract timestamps
                match = re.search(r'(\d{2}:\d{2}:\d{2}\.\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}\.\d{3})', timestamp_line)
                if match:
                    text = ' '.join(text_lines)
                    segments.append({
                        'start': match.group(1),
                        'end': match.group(2),
                        'text': text
                    })
        
        return segments
    
    @staticmethod
    def extract_all_text(vtt_content: str) -> str:
        """Extract all text from VTT"""
        segments = VTTParser.parse_vtt(vtt_content)
        return ' '.join([seg['text'] for seg in segments])


class TextComparator:
    """Compare two texts word-by-word"""
    
    @staticmethod
    def normalize_word(word: str) -> str:
        """Normalize word for comparison"""
        # Keep hyphens, remove other punctuation
        word = word.lower()
        word = re.sub(r'^[^\w-]+|[^\w-]+$', '', word)
        return word.strip()
    
    @staticmethod
    def tokenize(text: str) -> List[str]:
        """Tokenize text into normalized words"""
        words = text.split()
        normalized = [TextComparator.normalize_word(w) for w in words]
        return [w for w in normalized if w]  # Remove empty
    
    @staticmethod
    def find_differences(raw_text: str, vtt_text: str) -> Dict:
        """Find all differences between raw and VTT text"""
        raw_words = TextComparator.tokenize(raw_text)
        vtt_words = TextComparator.tokenize(vtt_text)
        
        matcher = SequenceMatcher(None, raw_words, vtt_words)
        
        differences = {
            'missing': [],  # In raw but not in VTT
            'added': [],    # In VTT but not in raw
            'replaced': [], # Different between raw and VTT
            'accuracy': matcher.ratio() * 100
        }
        
        for tag, i1, i2, j1, j2 in matcher.get_opcodes():
            if tag == 'delete':
                # Words in raw but missing from VTT
                for idx in range(i1, i2):
                    context_start = max(0, idx - 3)
                    context_end = min(len(raw_words), idx + 4)
                    context = ' '.join(raw_words[context_start:context_end])
                    
                    # Highlight the missing word
                    context_words = raw_words[context_start:context_end]
                    highlight_idx = idx - context_start
                    if 0 <= highlight_idx < len(context_words):
                        context_words[highlight_idx] = f">>>{context_words[highlight_idx]}<<<"
                    
                    differences['missing'].append({
                        'word': raw_words[idx],
                        'position': idx,
                        'context': ' '.join(context_words)
                    })
            
            elif tag == 'insert':
                # Words in VTT but not in raw
                for idx in range(j1, j2):
                    context_start = max(0, idx - 3)
                    context_end = min(len(vtt_words), idx + 4)
                    context = ' '.join(vtt_words[context_start:context_end])
                    
                    differences['added'].append({
                        'word': vtt_words[idx],
                        'position': idx,
                        'context': context
                    })
            
            elif tag == 'replace':
                # Words that are different
                for raw_idx, vtt_idx in zip(range(i1, i2), range(j1, j2)):
                    differences['replaced'].append({
                        'raw_word': raw_words[raw_idx],
                        'vtt_word': vtt_words[vtt_idx],
                        'position': raw_idx
                    })
        
        return differences
    
    @staticmethod
    def print_diff_report(differences: Dict, raw_text: str, vtt_text: str):
        """Print a detailed difference report"""
        print("\n" + "="*80)
        print("WORD-BY-WORD COMPARISON REPORT")
        print("="*80)
        
        raw_words = TextComparator.tokenize(raw_text)
        vtt_words = TextComparator.tokenize(vtt_text)
        
        print(f"\nüìä Statistics:")
        print(f"   Raw transcript words: {len(raw_words)}")
        print(f"   VTT output words: {len(vtt_words)}")
        print(f"   Accuracy: {differences['accuracy']:.2f}%")
        
        print(f"\n‚ùå Missing words (in raw, not in VTT): {len(differences['missing'])}")
        if differences['missing']:
            print("\n   Details:")
            for i, item in enumerate(differences['missing'][:10], 1):
                print(f"\n   {i}. Missing: '{item['word']}' at position {item['position']}")
                print(f"      Context: {item['context']}")
        
        print(f"\n‚ûï Added words (in VTT, not in raw): {len(differences['added'])}")
        if differences['added']:
            print("\n   Details:")
            for i, item in enumerate(differences['added'][:10], 1):
                print(f"\n   {i}. Added: '{item['word']}'")
                print(f"      Context: {item['context']}")
        
        print(f"\nüîÑ Replaced words: {len(differences['replaced'])}")
        if differences['replaced']:
            print("\n   Details:")
            for i, item in enumerate(differences['replaced'][:10], 1):
                print(f"\n   {i}. '{item['raw_word']}' ‚Üí '{item['vtt_word']}'")
        
        print("\n" + "="*80)


class TestActualVTTOutput(unittest.TestCase):
    """Test actual VTT output against raw transcript"""
    
    def test_user_provided_vtt(self):
        """Test the actual VTT output provided by the user"""
        
        # Raw transcript
        raw_transcript = """In this video, we're going to go over screen space reflections, which is a complex topic that deserves a little bit more time for discussion. Screen space reflections allow you to calculate reflections from the scene in real time without needing to use reflection probes, which we cover in the next module. This is a very intense effect, so reflection probes are the more performant option, but screen space reflections are an option if you're targeting very high-end devices. You're going to see this effect mostly on water, metallics, and other reflective materials. Once we've added screen space reflections onto our volume, let's take a look at it in action. Right now in our evening A scene here, the main thing that uses reflections are these air ducts above us. If I were to disable these reflection probes, we can see the color of these air ducts completely change, since after all these ducts are metallic and they reflect the light from the office around it. These reflection probes approximate the amount of light that the metallic air ducts are going to give off. Let's say I want to completely do away with reflection probes and have these use screen space reflections to approximate their reflection. What we can do is we can come over to the material that these air ducts use. So for example, if I select this and I can see that that the in the materials is air ducts B, I can go ahead and select air ducts B, toggle receive SSR, and I can do the same with these materials as well. Enable SSR on all of these air duct materials and now if I go into my volume here and I start messing around with the screen space reflection settings I can start getting these air ducts to reflect light using the scene itself rather than reflection probes. We can change the amount of smoothness. Minimum smoothness determines how smooth an object must be for SSR to be applied. Objects below this minimum use another reflection method such as probes. The smoothness fade start will set the smoothness value at which SSR reflections begin to fade out. Lower values results in HDRP fading out SSR reflections for less smooth game objects. We have some other settings here such as the ability to reflect the sky, the screen edge fade distance, as well as the object thickness. This controls how thick objects are inside of your scene. So if I set this thickness to one, we'll see more reflections on our ducks here because the rays are not passing through them as much. Additionally, we also have some quality settings here. So I can set this to high quality to get a bit of a better reflection. And we can also change the algorithm as well, from approximation to PBR accumulation. Approximation is a quicker algorithm, which results in less resources used, but it's not as accurate for rough surfaces. Something like PBR accumulation accumulates multiple frames to generate a more accurate result. And we can control the amount of accumulation using this accumulation factor. This gives a more accurate result, but it is more resource intensive and it can lead to some ghosting. Additionally, this algorithm cannot be used on transparent materials, as those will always use approximation. In the next video, we'll begin to discuss ray tracing. And for that video, I'm going to switch to a Windows machine. So if you are using a machine that doesn't support DirectX 12, such as a Mac, such as a Mac machine, feel free to watch along, despite the fact that you won't be able to preview the ray tracing effects in real time."""
        
        # Actual VTT output provided by user
        vtt_output = """WEBVTT

00:00:00.000 --> 00:00:05.310 align:middle line:84%
In this video, we're going to go over
screen space

00:00:05.360 --> 00:00:09.764 align:middle line:84%
reflections, which is a complex topic that
deserves a little bit more time for

00:00:09.814 --> 00:00:13.814 align:middle line:84%
discussion. Screen space reflections allow
you to calculate reflections from the

00:00:14.039 --> 00:00:18.744 align:middle line:84%
scene in real time without needing to use
reflection probes, which we cover in the

00:00:18.794 --> 00:00:23.398 align:middle line:84%
next module. This is a very intense
effect, so reflection probes are the more

00:00:23.480 --> 00:00:27.910 align:middle line:84%
performant option, but screen space
reflections are an option if you're

00:00:27.960 --> 00:00:32.490 align:middle line:84%
very high -end devices. You're going to
see this effect mostly on water,

00:00:32.539 --> 00:00:34.089 align:middle line:90%
metallics, and other reflective

00:00:34.159 --> 00:00:39.010 align:middle line:84%
materials. Once we've added screen space
reflections onto our volume,

00:00:39.060 --> 00:00:41.162 align:middle line:90%
let's take a look at it in

00:00:41.212 --> 00:00:45.816 align:middle line:84%
action. Right now in our evening A scene
here, the main thing that uses

00:00:45.866 --> 00:00:47.716 align:middle line:90%
reflections are these air ducts above

00:00:47.979 --> 00:00:52.810 align:middle line:84%
us. If I were to disable these reflection
probes, we can see the

00:00:52.859 --> 00:00:57.264 align:middle line:84%
color of these air ducts completely
change, since after all these ducts are

00:00:57.314 --> 00:01:00.016 align:middle line:84%
and they reflect the light from the office
around

00:01:00.840 --> 00:01:06.450 align:middle line:84%
it. These reflection probes approximate
the amount of

00:01:06.500 --> 00:01:09.503 align:middle line:84%
light that the metallic air ducts are
going to give

00:01:09.553 --> 00:01:14.257 align:middle line:84%
off. Let's say I want to completely do
away with reflection probes and have these

00:01:14.307 --> 00:01:16.757 align:middle line:84%
use screen space reflections to
approximate their

00:01:16.807 --> 00:01:22.112 align:middle line:84%
reflection. What we can do is we can come
over to the material that these air ducts

00:01:22.162 --> 00:01:27.667 align:middle line:84%
use. So for example, if I select this and
I can see that that the in the

00:01:27.717 --> 00:01:32.321 align:middle line:84%
materials is air ducts B, I can go ahead
and select air ducts B,

00:01:32.371 --> 00:01:35.875 align:middle line:84%
toggle receive SSR, and I can do the same
with these

00:01:35.925 --> 00:01:39.428 align:middle line:84%
materials as well. Enable SSR on all of
these air duct

00:01:43.260 --> 00:01:46.863 align:middle line:84%
materials and now if I go into my volume
here and I

00:01:53.780 --> 00:01:58.510 align:middle line:84%
start messing around with the screen space
reflection settings I can start getting

00:01:58.560 --> 00:02:03.769 align:middle line:84%
these air ducts to reflect light using the
scene itself

00:02:03.819 --> 00:02:08.229 align:middle line:84%
rather than reflection probes. We can
change the amount of

00:02:08.280 --> 00:02:13.209 align:middle line:84%
smoothness. Minimum smoothness determines
how smooth an object must

00:02:13.259 --> 00:02:17.929 align:middle line:84%
be for SSR to be applied. Objects below
this minimum use

00:02:17.979 --> 00:02:19.709 align:middle line:90%
another reflection method such as

00:02:19.759 --> 00:02:24.769 align:middle line:84%
probes. The smoothness fade start will set
the smoothness

00:02:24.819 --> 00:02:27.289 align:middle line:84%
value at which SSR reflections begin to
fade

00:02:27.340 --> 00:02:32.189 align:middle line:84%
out. Lower values results in HDRP fading
out SSR reflections

00:02:32.240 --> 00:02:36.989 align:middle line:84%
for less smooth game objects. We have some
other settings here

00:02:37.039 --> 00:02:41.329 align:middle line:84%
such as the ability to reflect the sky,
the screen edge fade

00:02:41.379 --> 00:02:44.109 align:middle line:90%
distance, as well as the object

00:02:44.159 --> 00:02:47.869 align:middle line:84%
thickness. This controls how thick objects
are inside of your

00:02:47.919 --> 00:02:52.709 align:middle line:84%
scene. So if I set this thickness to one,
we'll see more

00:02:52.759 --> 00:02:57.810 align:middle line:84%
reflections on our ducks here because the
rays are not

00:02:57.860 --> 00:03:02.849 align:middle line:84%
passing through them as much.
Additionally, we also

00:03:02.900 --> 00:03:04.200 align:middle line:90%
have some quality settings

00:03:04.250 --> 00:03:09.254 align:middle line:84%
here. So I can set this to high quality to
get a bit of a better

00:03:09.304 --> 00:03:12.207 align:middle line:84%
reflection. And we can also change the
algorithm as

00:03:13.780 --> 00:03:17.609 align:middle line:90%
well, from approximation to PBR

00:03:17.659 --> 00:03:22.569 align:middle line:84%
accumulation. Approximation is a quicker
algorithm, which results in

00:03:22.620 --> 00:03:25.929 align:middle line:84%
less resources used, but it's not as
accurate for rough

00:03:25.979 --> 00:03:30.549 align:middle line:84%
surfaces. Something like PBR accumulation
accumulates multiple

00:03:30.599 --> 00:03:32.401 align:middle line:90%
frames to generate a more accurate

00:03:32.451 --> 00:03:36.301 align:middle line:84%
result. And we can control the amount of
accumulation using this accumulation

00:03:37.060 --> 00:03:42.929 align:middle line:90%
factor. This gives a more accurate

00:03:42.979 --> 00:03:47.083 align:middle line:84%
result, but it is more resource intensive
and it can lead to some

00:03:47.133 --> 00:03:51.233 align:middle line:84%
ghosting. Additionally, this algorithm
cannot be used on transparent materials,

00:03:51.860 --> 00:03:56.469 align:middle line:84%
those will always use approximation. In
the next video, we'll begin to

00:03:56.520 --> 00:04:01.124 align:middle line:84%
discuss ray tracing. And for that video,
I'm going to switch to a Windows

00:04:01.174 --> 00:04:06.379 align:middle line:84%
machine. So if you are using a machine
that doesn't support DirectX 12, such as a

00:04:06.429 --> 00:04:11.533 align:middle line:84%
Mac, such as a Mac machine, feel free to
watch along, despite the fact that

00:04:11.583 --> 00:04:15.187 align:middle line:84%
you won't be able to preview the ray
tracing effects in real

00:04:15.237 --> 00:04:16.487 align:middle line:90%
time."""
        
        # Parse VTT
        vtt_text = VTTParser.extract_all_text(vtt_output)
        
        # Compare
        comparator = TextComparator()
        differences = comparator.find_differences(raw_transcript, vtt_text)
        
        # Print detailed report
        comparator.print_diff_report(differences, raw_transcript, vtt_text)
        
        # Assertions
        self.assertEqual(len(differences['missing']), 0,
                        f"\n‚ùå FAILED: {len(differences['missing'])} words missing from VTT!\n" +
                        "\n".join([f"  - '{m['word']}' at position {m['position']}" 
                                  for m in differences['missing'][:5]]))
        
        self.assertEqual(len(differences['added']), 0,
                        f"\n‚ùå FAILED: {len(differences['added'])} words added to VTT!")
        
        self.assertGreaterEqual(differences['accuracy'], 99.9,
                               f"\n‚ùå FAILED: Accuracy is {differences['accuracy']:.2f}%, expected >= 99.9%")


def run_tests():
    """Run the VTT validation test"""
    loader = unittest.TestLoader()
    suite = loader.loadTestsFromTestCase(TestActualVTTOutput)
    
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    print("\n" + "="*80)
    if result.wasSuccessful():
        print("‚úÖ ALL TESTS PASSED - VTT output is correct!")
    else:
        print("‚ùå TESTS FAILED - VTT output has issues!")
    print("="*80)
    
    return result


if __name__ == '__main__':
    run_tests()
