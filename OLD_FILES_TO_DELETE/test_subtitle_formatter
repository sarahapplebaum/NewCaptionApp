import unittest
from typing import List, Dict
from captioner import OptimizedSubtitleFormatter

class TestOptimizedSubtitleFormatter(unittest.TestCase):
    """Comprehensive test suite for OptimizedSubtitleFormatter"""
    
    def setUp(self):
        """Set up test fixtures"""
        self.formatter = OptimizedSubtitleFormatter
    
    # ==================== TEXT FORMATTING TESTS ====================
    
    def test_format_text_simple(self):
        """Test basic text formatting"""
        text = "Hello world this is a test"
        result, overflow = self.formatter.format_text_optimized(text, max_chars_per_line=20)
        
        self.assertIn("Hello world", result)
        self.assertEqual(len(overflow), 0)
    
    def test_format_text_long_line(self):
        """Test text that exceeds max chars per line"""
        text = "This is a very long sentence that should be split across multiple lines"
        result, overflow = self.formatter.format_text_optimized(text, max_chars_per_line=30, max_lines=2)
        
        lines = result.split('\n')
        self.assertEqual(len(lines), 2)
        self.assertGreater(len(overflow), 0)
    
    def test_format_text_empty(self):
        """Test empty text handling"""
        result, overflow = self.formatter.format_text_optimized("")
        self.assertEqual(result, "")
        self.assertEqual(overflow, [])
    
    def test_format_text_single_long_word(self):
        """Test handling of single word exceeding max chars"""
        text = "Supercalifragilisticexpialidocious test"
        result, overflow = self.formatter.format_text_optimized(text, max_chars_per_line=20)
        
        self.assertIn("...", result)
    
    # ==================== WORD CLEANING TESTS ====================
    
    def test_clean_words_basic(self):
        """Test basic word cleaning"""
        words = [
            {"word": "Hello", "start": 0.0, "end": 0.5},
            {"word": "world", "start": 0.5, "end": 1.0}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        self.assertEqual(len(cleaned), 2)
        self.assertEqual(cleaned[0].word, "Hello")
        self.assertEqual(cleaned[1].word, "world")
    
    def test_clean_words_remove_period_mid_sentence(self):
        """Test period removal before lowercase continuation"""
        words = [
            {"word": "outside.", "start": 0.0, "end": 0.5},
            {"word": "of", "start": 0.5, "end": 1.0}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        self.assertEqual(cleaned[0].word, "outside")  # Period removed
        self.assertEqual(cleaned[1].word, "of")
    
    def test_clean_words_keep_period_before_and(self):
        """Test period retention before sentence-starting 'And'"""
        words = [
            {"word": "devices.", "start": 0.0, "end": 0.5},
            {"word": "And", "start": 0.5, "end": 1.0}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        self.assertEqual(cleaned[0].word, "devices.")  # Period kept
        self.assertEqual(cleaned[1].word, "And")
    
    def test_clean_words_keep_period_before_so(self):
        """Test period retention before 'So'"""
        words = [
            {"word": "good.", "start": 0.0, "end": 0.5},
            {"word": "So", "start": 0.5, "end": 1.0}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        self.assertEqual(cleaned[0].word, "good.")  # Period kept
    
    def test_clean_words_excessive_repetition(self):
        """Test filtering of excessive word repetition"""
        words = [
            {"word": "the", "start": i * 0.5, "end": (i + 1) * 0.5}
            for i in range(20)
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        # Should keep only 3 occurrences of highly repetitive word
        self.assertLessEqual(len(cleaned), 3)
    
    def test_clean_words_empty_input(self):
        """Test empty word list"""
        cleaned = self.formatter.clean_and_process_words([])
        self.assertEqual(len(cleaned), 0)
    
    def test_clean_words_missing_timestamps(self):
        """Test handling of missing timestamps"""
        words = [
            {"word": "hello"},  # Missing start/end
            {"word": "world", "start": 1.0, "end": 2.0}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        self.assertEqual(len(cleaned), 2)
        self.assertEqual(cleaned[0].start, 0.0)  # Default value
    
    # ==================== SEGMENT CREATION TESTS ====================
    
    def test_create_segments_basic(self):
        """Test basic segment creation"""
        words = [
            {"word": "Hello", "start": 0.0, "end": 0.5},
            {"word": "world", "start": 0.5, "end": 1.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        self.assertGreater(len(segments), 0)
        self.assertIn("Hello", segments[0]["text"])
    
    def test_create_segments_max_chars_break(self):
        """Test segment breaking at max characters"""
        words = [
            {"word": word, "start": i * 0.5, "end": (i + 1) * 0.5}
            for i, word in enumerate("This is a very long sentence that should be split into multiple segments".split())
        ]
        
        segments = self.formatter.create_optimized_segments(words, max_chars=30)
        
        self.assertGreater(len(segments), 1)
        for segment in segments:
            self.assertLessEqual(len(segment["text"]), 100)  # Reasonable upper bound
    
    def test_create_segments_sentence_boundary(self):
        """Test segment breaking at sentence boundaries"""
        words = [
            {"word": "First", "start": 0.0, "end": 0.5},
            {"word": "sentence.", "start": 0.5, "end": 1.0},
            {"word": "Second", "start": 1.0, "end": 1.5},
            {"word": "sentence.", "start": 1.5, "end": 2.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words, max_chars=100)
        
        # Should create separate segments for each sentence
        self.assertGreaterEqual(len(segments), 1)
    
    def test_create_segments_time_gap(self):
        """Test segment breaking at time gaps"""
        words = [
            {"word": "First", "start": 0.0, "end": 0.5},
            {"word": "part", "start": 0.5, "end": 1.0},
            {"word": "Second", "start": 5.0, "end": 5.5},  # Large gap
            {"word": "part", "start": 5.5, "end": 6.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        self.assertEqual(len(segments), 2)
    
    def test_create_segments_empty_input(self):
        """Test empty word list"""
        segments = self.formatter.create_optimized_segments([])
        self.assertEqual(len(segments), 0)
    
    # ==================== PUNCTUATION CLEANING TESTS ====================
    
    def test_segment_punctuation_remove_mid_sentence_period(self):
        """Test removal of period when sentence continues"""
        segments = [
            {"text": "go ahead and go outside.", "start": 0.0, "end": 2.0},
            {"text": "of this environment here", "start": 2.0, "end": 4.0}
        ]
        
        cleaned = self.formatter.clean_segment_punctuation(segments)
        
        self.assertEqual(cleaned[0]["text"], "go ahead and go outside")  # Period removed
    
    def test_segment_punctuation_keep_before_and(self):
        """Test keeping period before 'And'"""
        segments = [
            {"text": "this looks good.", "start": 0.0, "end": 2.0},
            {"text": "And I'm going to add", "start": 2.0, "end": 4.0}
        ]
        
        cleaned = self.formatter.clean_segment_punctuation(segments)
        
        self.assertEqual(cleaned[0]["text"], "this looks good.")  # Period kept
    
    def test_segment_punctuation_keep_before_so(self):
        """Test keeping period before 'So'"""
        segments = [
            {"text": "the more performant option.", "start": 0.0, "end": 2.0},
            {"text": "So if you are using", "start": 2.0, "end": 4.0}
        ]
        
        cleaned = self.formatter.clean_segment_punctuation(segments)
        
        self.assertEqual(cleaned[0]["text"], "the more performant option.")
    
    def test_segment_punctuation_single_segment(self):
        """Test single segment (no cleaning needed)"""
        segments = [{"text": "Only segment.", "start": 0.0, "end": 2.0}]
        
        cleaned = self.formatter.clean_segment_punctuation(segments)
        
        self.assertEqual(len(cleaned), 1)
        self.assertEqual(cleaned[0]["text"], "Only segment.")
    
    # ==================== TIMING TESTS ====================
    
    def test_calculate_reading_time_short(self):
        """Test reading time for short text"""
        time = self.formatter.calculate_reading_time("Hello world")
        
        self.assertGreaterEqual(time, self.formatter.MIN_DURATION)
        self.assertLessEqual(time, self.formatter.MAX_DURATION)
    
    def test_calculate_reading_time_long(self):
        """Test reading time for long text"""
        long_text = " ".join(["word"] * 50)
        time = self.formatter.calculate_reading_time(long_text)
        
        self.assertGreater(time, self.formatter.MIN_DURATION)
        self.assertLessEqual(time, self.formatter.MAX_DURATION)
    
    def test_calculate_reading_time_empty(self):
        """Test reading time for empty text"""
        time = self.formatter.calculate_reading_time("")
        
        self.assertEqual(time, self.formatter.MIN_DURATION)
    
    def test_calculate_reading_time_with_punctuation(self):
        """Test that punctuation adds time"""
        simple = self.formatter.calculate_reading_time("Hello world")
        complex = self.formatter.calculate_reading_time("Hello, world! How are you?")
        
        self.assertGreater(complex, simple)
    
    # ==================== VTT FORMAT TESTS ====================
    
    def test_vtt_format_basic(self):
        """Test basic VTT output"""
        segments = [
            {"text": "Hello world", "start": 0.0, "end": 2.0}
        ]
        
        vtt = self.formatter.create_vtt_optimized(segments)
        
        self.assertIn("WEBVTT", vtt)
        self.assertIn("00:00:00.000", vtt)
        self.assertIn("Hello world", vtt)
    
    def test_vtt_format_multiple_segments(self):
        """Test VTT with multiple segments"""
        segments = [
            {"text": "First segment", "start": 0.0, "end": 2.0},
            {"text": "Second segment", "start": 2.0, "end": 4.0}
        ]
        
        vtt = self.formatter.create_vtt_optimized(segments)
        
        self.assertIn("First segment", vtt)
        self.assertIn("Second segment", vtt)
        self.assertEqual(vtt.count("-->"), 2)
    
    def test_vtt_format_empty(self):
        """Test VTT with empty segments"""
        vtt = self.formatter.create_vtt_optimized([])
        
        self.assertEqual(vtt, "WEBVTT\n\n")
    
    def test_vtt_format_timing(self):
        """Test VTT timing format"""
        segments = [{"text": "Test", "start": 65.5, "end": 67.5}]
        
        vtt = self.formatter.create_vtt_optimized(segments)
        
        self.assertIn("00:01:05.500", vtt)  # 65.5 seconds
    
    # ==================== SRT FORMAT TESTS ====================
    
    def test_srt_format_basic(self):
        """Test basic SRT output"""
        segments = [
            {"text": "Hello world", "start": 0.0, "end": 2.0}
        ]
        
        srt = self.formatter.create_srt_optimized(segments)
        
        self.assertIn("1\n", srt)  # Counter
        self.assertIn("00:00:00,000", srt)  # Comma separator
        self.assertIn("Hello world", srt)
    
    def test_srt_format_multiple_segments(self):
        """Test SRT with multiple segments"""
        segments = [
            {"text": "First", "start": 0.0, "end": 2.0},
            {"text": "Second", "start": 2.0, "end": 4.0}
        ]
        
        srt = self.formatter.create_srt_optimized(segments)
        
        self.assertIn("1\n", srt)
        self.assertIn("2\n", srt)
    
    def test_srt_format_timing(self):
        """Test SRT timing format with comma"""
        segments = [{"text": "Test", "start": 65.5, "end": 67.5}]
        
        srt = self.formatter.create_srt_optimized(segments)
        
        self.assertIn("00:01:05,500", srt)  # Comma, not period
    
    # ==================== SENTENCE BOUNDARY TESTS ====================
    
    def test_is_sentence_boundary_period(self):
        """Test period detection"""
        self.assertTrue(self.formatter.is_sentence_boundary("word."))
        self.assertTrue(self.formatter.is_sentence_boundary("word!"))
        self.assertTrue(self.formatter.is_sentence_boundary("word?"))
    
    def test_is_sentence_boundary_abbreviation(self):
        """Test abbreviation handling"""
        self.assertFalse(self.formatter.is_sentence_boundary("Dr."))
        self.assertFalse(self.formatter.is_sentence_boundary("Mr."))
        self.assertFalse(self.formatter.is_sentence_boundary("Inc."))
    
    def test_is_sentence_boundary_no_punctuation(self):
        """Test words without punctuation"""
        self.assertFalse(self.formatter.is_sentence_boundary("word"))
    
    def test_is_natural_pause_comma(self):
        """Test comma as natural pause"""
        self.assertTrue(self.formatter.is_natural_pause("word,"))
        self.assertTrue(self.formatter.is_natural_pause("word;"))
    
    # ==================== EDGE CASES ====================
    
    def test_edge_case_none_values(self):
        """Test handling of None values"""
        words = [
            {"word": None, "start": 0.0, "end": 1.0},
            {"word": "valid", "start": 1.0, "end": 2.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        self.assertGreater(len(segments), 0)
    
    def test_edge_case_negative_timestamps(self):
        """Test handling of negative timestamps"""
        words = [
            {"word": "test", "start": -1.0, "end": -0.5}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        # Should handle gracefully
        self.assertIsInstance(segments, list)
    
    def test_edge_case_very_long_word(self):
        """Test handling of extremely long words"""
        words = [
            {"word": "a" * 200, "start": 0.0, "end": 1.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        self.assertGreater(len(segments), 0)
    
    # ==================== INTEGRATION TESTS ====================
    
    def test_integration_full_pipeline(self):
        """Test complete pipeline from words to VTT"""
        words = [
            {"word": "In", "start": 0.0, "end": 0.2},
            {"word": "this", "start": 0.2, "end": 0.4},
            {"word": "video.", "start": 0.4, "end": 0.8},
            {"word": "we're", "start": 0.8, "end": 1.0},
            {"word": "going", "start": 1.0, "end": 1.2},
            {"word": "to", "start": 1.2, "end": 1.4},
            {"word": "talk", "start": 1.4, "end": 1.6}
        ]
        
        segments = self.formatter.create_optimized_segments(words, max_chars=50)
        vtt = self.formatter.create_vtt_optimized(segments, max_chars_per_line=40)
        
        self.assertIn("WEBVTT", vtt)
        self.assertIn("this video", vtt)
        self.assertIn("going to talk", vtt)
    
    def test_integration_user_example_clouds(self):
        """Test with actual user example from clouds video"""
        words = [
            {"word": "outside.", "start": 8.4, "end": 8.8},
            {"word": "of", "start": 8.8, "end": 9.0},
            {"word": "this", "start": 9.0, "end": 9.2},
            {"word": "environment", "start": 9.2, "end": 9.6},
            {"word": "here", "start": 9.6, "end": 9.8},
            {"word": "And", "start": 9.8, "end": 10.0}
        ]
        
        segments = self.formatter.create_optimized_segments(words)
        
        # Verify period handling
        first_seg_text = segments[0]["text"] if segments else ""
        
        # Should remove period before "of" but segment should break before "And"
        self.assertIn("outside", first_seg_text)
        
    def test_integration_user_example_reflections(self):
        """Test with user example from reflections video"""
        words = [
            {"word": "targeting", "start": 27.9, "end": 28.2},
            {"word": "very", "start": 28.2, "end": 28.4},
            {"word": "high", "start": 28.4, "end": 28.6},
            {"word": "-end", "start": 28.6, "end": 28.9},
            {"word": "devices.", "start": 28.9, "end": 29.3},
            {"word": "You're", "start": 29.3, "end": 29.5}
        ]
        
        cleaned = self.formatter.clean_and_process_words(words)
        
        # Verify "targeting" is not dropped
        words_list = [w.word for w in cleaned]
        self.assertIn("targeting", words_list)
        
        # Verify period before "You're" is kept
        for i, w in enumerate(cleaned):
            if w.word.startswith("devices"):
                self.assertTrue(w.word.endswith("."))

# ==================== PERFORMANCE TESTS ====================

class TestPerformance(unittest.TestCase):
    """Performance and efficiency tests"""
    
    def test_performance_large_word_list(self):
        """Test performance with large word list"""
        import time
        
        # Create 1000 words
        words = [
            {"word": f"word{i}", "start": i * 0.5, "end": (i + 1) * 0.5}
            for i in range(1000)
        ]
        
        start = time.time()
        segments = OptimizedSubtitleFormatter.create_optimized_segments(words)
        elapsed = time.time() - start
        
        self.assertLess(elapsed, 2.0)  # Should complete in under 2 seconds
        self.assertGreater(len(segments), 0)
    
    def test_performance_vtt_generation(self):
        """Test VTT generation performance"""
        import time
        
        segments = [
            {"text": f"Segment {i}", "start": i * 2.0, "end": (i + 1) * 2.0}
            for i in range(100)
        ]
        
        start = time.time()
        vtt = OptimizedSubtitleFormatter.create_vtt_optimized(segments)
        elapsed = time.time() - start
        
        self.assertLess(elapsed, 1.0)  # Should be fast
        self.assertIn("WEBVTT", vtt)

# ==================== RUN TESTS ====================

def run_tests():
    """Run all tests with detailed output"""
    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Add all test classes
    suite.addTests(loader.loadTestsFromTestCase(TestOptimizedSubtitleFormatter))
    suite.addTests(loader.loadTestsFromTestCase(TestPerformance))
    
    # Run with verbose output
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Print summary
    print("\n" + "="*70)
    print(f"Tests run: {result.testsRun}")
    print(f"Successes: {result.testsRun - len(result.failures) - len(result.errors)}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    print("="*70)
    
    return result

if __name__ == '__main__':
    run_tests()
