#!/usr/bin/env python3
"""
Test existing caption files generated by batch processing
Validates all 5 requirements on pre-generated VTT files
"""

import os
import sys
from pathlib import Path
from typing import Dict, List, Tuple
import argparse

# Add current directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

class ExistingCaptionTest:
    """Test existing caption files"""
    
    def __init__(self):
        self.test_results = []
        
    def test_vtt_file_creation(self, vtt_path: Path) -> bool:
        """Test 1: VTT file was created and saved"""
        print("\nüß™ TEST 1: VTT File Creation and Saving")
        print("-" * 50)
        
        try:
            if not vtt_path.exists():
                print("‚ùå VTT file was not created")
                return False
            
            file_size = vtt_path.stat().st_size
            if file_size == 0:
                print("‚ùå VTT file is empty")
                return False
            
            # Check if it's valid VTT
            with open(vtt_path, 'r', encoding='utf-8-sig') as f:
                content = f.read()
            
            if not content.startswith("WEBVTT"):
                print("‚ùå Invalid VTT format")
                return False
            
            print(f"‚úÖ VTT file successfully created: {vtt_path.name}")
            print(f"   File size: {file_size} bytes")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def test_word_preservation(self, txt_path: Path, vtt_path: Path) -> bool:
        """Test 2: All words preserved in VTT"""
        print("\nüß™ TEST 2: Word Preservation")
        print("-" * 50)
        
        try:
            # Read original text
            with open(txt_path, 'r', encoding='utf-8-sig') as f:
                original_text = f.read().strip()
            
            # Read VTT and extract text
            with open(vtt_path, 'r', encoding='utf-8-sig') as f:
                vtt_content = f.read()
            
            # Extract text from VTT segments
            vtt_text_parts = []
            lines = vtt_content.split('\n')
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                
                # Skip until timestamp
                if '-->' not in line:
                    i += 1
                    continue
                
                # Collect subtitle text lines
                i += 1
                while i < len(lines) and lines[i].strip():
                    vtt_text_parts.append(lines[i].strip())
                    i += 1
                i += 1
            
            vtt_text = ' '.join(vtt_text_parts)
            
            # Compare word counts
            original_words = original_text.split()
            vtt_words = vtt_text.split()
            
            original_words_clean = [w.lower().strip('.,!?";:\'"') for w in original_words if w.strip()]
            vtt_words_clean = [w.lower().strip('.,!?";:\'"') for w in vtt_words if w.strip()]
            
            print(f"üìù Original text: {len(original_words)} words")
            print(f"üì¶ VTT text: {len(vtt_words)} words")
            
            # Check for missing words
            original_set = set(original_words_clean)
            vtt_set = set(vtt_words_clean)
            missing_words = original_set - vtt_set
            
            if missing_words:
                print(f"‚ùå Missing words detected: {list(missing_words)[:10]}...")
                print(f"   Missing count: {len(missing_words)}")
                return False
            
            # Check word counts
            word_count_errors = []
            original_counts = {}
            vtt_counts = {}
            
            for word in original_words_clean:
                original_counts[word] = original_counts.get(word, 0) + 1
            
            for word in vtt_words_clean:
                vtt_counts[word] = vtt_counts.get(word, 0) + 1
            
            for word, orig_count in original_counts.items():
                vtt_count = vtt_counts.get(word, 0)
                if vtt_count < orig_count:
                    word_count_errors.append(f"'{word}': {orig_count} ‚Üí {vtt_count}")
            
            if word_count_errors:
                print(f"‚ùå Word count mismatches:")
                for error in word_count_errors[:10]:
                    print(f"   {error}")
                return False
            
            print(f"‚úÖ All words preserved successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def test_42_character_limit(self, vtt_path: Path) -> bool:
        """Test 3: 42 character line limit"""
        print("\nüß™ TEST 3: 42 Character Line Limit")
        print("-" * 50)
        
        try:
            with open(vtt_path, 'r', encoding='utf-8-sig') as f:
                content = f.read()
            
            lines = content.split('\n')
            violations = []
            subtitle_lines = []
            
            for i, line in enumerate(lines, 1):
                # Skip headers, timestamps, empty lines
                if (not line.strip() or 
                    line.strip().startswith('WEBVTT') or
                    '-->' in line or
                    line.strip().startswith('NOTE')):
                    continue
                
                subtitle_lines.append((i, line))
                
                if len(line) > 42:
                    violations.append(f"Line {i}: '{line}' ({len(line)} chars)")
            
            if violations:
                print(f"‚ùå Lines exceeding 42 characters:")
                for violation in violations[:10]:
                    print(f"   {violation}")
                return False
            
            max_length = max((len(line) for _, line in subtitle_lines), default=0)
            print(f"‚úÖ All lines within 42 character limit")
            print(f"   Checked {len(subtitle_lines)} lines, max length: {max_length}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def test_2_line_limit(self, vtt_path: Path) -> bool:
        """Test 4: 2 line subtitle limit"""
        print("\nüß™ TEST 4: 2 Line Subtitle Limit")
        print("-" * 50)
        
        try:
            with open(vtt_path, 'r', encoding='utf-8-sig') as f:
                content = f.read()
            
            lines = content.split('\n')
            violations = []
            subtitle_count = 0
            line_counts = []
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                
                # Skip until timestamp
                if '-->' not in line:
                    i += 1
                    continue
                
                # Count subtitle lines
                i += 1
                current_lines = 0
                subtitle_text = []
                
                while i < len(lines) and lines[i].strip():
                    current_lines += 1
                    subtitle_text.append(lines[i])
                    i += 1
                
                subtitle_count += 1
                line_counts.append(current_lines)
                
                if current_lines > 2:
                    violations.append(f"Subtitle {subtitle_count}: {current_lines} lines")
                    for j, text_line in enumerate(subtitle_text[:3]):
                        violations.append(f"  Line {j+1}: '{text_line}'")
                
                i += 1
            
            if violations:
                print(f"‚ùå Subtitles exceeding 2 line limit:")
                for violation in violations[:20]:
                    print(f"   {violation}")
                return False
            
            max_lines = max(line_counts) if line_counts else 0
            avg_lines = sum(line_counts) / len(line_counts) if line_counts else 0
            
            print(f"‚úÖ All subtitles within 2 line limit")
            print(f"   Checked {subtitle_count} subtitles")
            print(f"   Max lines: {max_lines}, Average: {avg_lines:.1f}")
            
            return True
            
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def test_word_order(self, txt_path: Path, vtt_path: Path) -> bool:
        """Test 5: Word order preservation"""
        print("\nüß™ TEST 5: Word Order Preservation")
        print("-" * 50)
        
        try:
            # Read original text
            with open(txt_path, 'r', encoding='utf-8-sig') as f:
                original_text = f.read().strip()
            
            # Read VTT and extract text in order
            with open(vtt_path, 'r', encoding='utf-8-sig') as f:
                vtt_content = f.read()
            
            # Extract text from VTT segments in chronological order
            vtt_segments = []
            lines = vtt_content.split('\n')
            
            i = 0
            while i < len(lines):
                line = lines[i].strip()
                
                # Skip until timestamp
                if '-->' not in line:
                    i += 1
                    continue
                
                # Extract timestamp for ordering
                timestamp_line = line
                start_time = timestamp_line.split(' --> ')[0]
                
                # Collect subtitle text lines
                i += 1
                subtitle_text = []
                while i < len(lines) and lines[i].strip():
                    subtitle_text.append(lines[i].strip())
                    i += 1
                
                if subtitle_text:
                    vtt_segments.append({
                        'timestamp': start_time,
                        'text': ' '.join(subtitle_text)
                    })
                
                i += 1
            
            # Sort by timestamp to ensure chronological order
            vtt_segments.sort(key=lambda x: x['timestamp'])
            
            # Extract sequential words from both sources
            original_words = original_text.split()
            vtt_words = []
            
            for segment in vtt_segments:
                vtt_words.extend(segment['text'].split())
            
            # Clean words for comparison (remove punctuation, normalize case)
            def clean_word(word):
                return word.lower().strip('.,!?";:\'"()[]{}')
            
            original_clean = [clean_word(w) for w in original_words if clean_word(w)]
            vtt_clean = [clean_word(w) for w in vtt_words if clean_word(w)]
            
            print(f"üìù Original sequence: {len(original_clean)} words")
            print(f"üì¶ VTT sequence: {len(vtt_clean)} words")
            
            # Check if we have reasonable word counts to compare
            if len(vtt_clean) == 0:
                print("‚ùå No words found in VTT")
                return False
            
            # Find the longest common subsequence to identify order issues
            order_errors = []
            vtt_idx = 0
            
            for i, orig_word in enumerate(original_clean):
                # Find this word in the remaining VTT words
                found = False
                search_start = vtt_idx
                
                # Look ahead up to 10 words to handle minor reordering
                search_end = min(len(vtt_clean), vtt_idx + 10)
                
                for j in range(search_start, search_end):
                    if vtt_clean[j] == orig_word:
                        # Found the word, update position
                        if j > vtt_idx:
                            # Words were skipped - they might be out of order
                            skipped_words = vtt_clean[vtt_idx:j]
                            if len(skipped_words) > 0:
                                order_errors.append(f"Skipped words before '{orig_word}': {skipped_words}")
                        
                        vtt_idx = j + 1
                        found = True
                        break
                
                if not found:
                    # Word not found in expected position - major order issue
                    if vtt_idx < len(vtt_clean):
                        expected_next = vtt_clean[vtt_idx:vtt_idx+3]
                        order_errors.append(f"Expected '{orig_word}' but found: {expected_next}")
                    else:
                        order_errors.append(f"Expected '{orig_word}' but reached end of VTT")
                    
                    # Skip this word and continue
                    continue
            
            # Evaluate results
            if len(order_errors) > 5:  # Allow a few minor order issues
                print(f"‚ùå Significant word order issues detected:")
                for error in order_errors[:10]:  # Show first 10 errors
                    print(f"   {error}")
                print(f"   Total order issues: {len(order_errors)}")
                return False
            elif len(order_errors) > 0:
                print(f"‚ö†Ô∏è  Minor word order issues detected ({len(order_errors)} issues):")
                for error in order_errors[:5]:
                    print(f"   {error}")
                print(f"‚úÖ Word order generally preserved (within tolerance)")
                return True
            else:
                print(f"‚úÖ Perfect word order preservation")
                print(f"   All {len(original_clean)} words appear in correct sequence")
                return True
            
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False
    
    def test_single_video(self, video_base: str, directory: Path) -> Dict[str, bool]:
        """Test a single video's caption files"""
        print(f"\n{'='*60}")
        print(f"üé¨ Testing: {video_base}")
        print(f"{'='*60}")
        
        txt_path = directory / f"{video_base}.txt"
        vtt_path = directory / f"{video_base}.vtt"
        
        # Check if files exist
        if not txt_path.exists():
            print(f"‚ùå TXT file not found: {txt_path.name}")
            return {}
        
        if not vtt_path.exists():
            print(f"‚ùå VTT file not found: {vtt_path.name}")
            return {}
        
        # Run all tests
        tests = [
            ("VTT File Creation", lambda: self.test_vtt_file_creation(vtt_path)),
            ("Word Preservation", lambda: self.test_word_preservation(txt_path, vtt_path)),
            ("42 Character Limit", lambda: self.test_42_character_limit(vtt_path)),
            ("2 Line Limit", lambda: self.test_2_line_limit(vtt_path)),
            ("Word Order Preservation", lambda: self.test_word_order(txt_path, vtt_path))
        ]
        
        results = {}
        
        for test_name, test_func in tests:
            try:
                result = test_func()
                results[test_name] = result
            except Exception as e:
                results[test_name] = False
                print(f"üí• {test_name}: ERROR - {e}")
        
        return results
    
    def test_all_videos(self, directory: Path) -> None:
        """Test all videos in directory"""
        print("üöÄ BATCH CAPTION TEST")
        print("=" * 60)
        print(f"üìÅ Directory: {directory}")
        print()
        
        # Find all VTT files
        vtt_files = list(directory.glob("*.vtt"))
        
        if not vtt_files:
            print("‚ùå No VTT files found in directory")
            return
        
        print(f"üìä Found {len(vtt_files)} VTT files to test")
        
        # Test each video
        all_results = {}
        
        for vtt_path in sorted(vtt_files):
            video_base = vtt_path.stem
            results = self.test_single_video(video_base, directory)
            
            if results:
                all_results[video_base] = results
        
        # Print summary
        print("\n" + "=" * 60)
        print("üìä BATCH TEST SUMMARY")
        print("=" * 60)
        
        total_videos = len(all_results)
        test_names = ["VTT File Creation", "Word Preservation", "42 Character Limit", 
                      "2 Line Limit", "Word Order Preservation"]
        
        # Count passes per test
        test_passes = {test: 0 for test in test_names}
        perfect_videos = []
        
        for video, results in all_results.items():
            all_passed = True
            for test in test_names:
                if results.get(test, False):
                    test_passes[test] += 1
                else:
                    all_passed = False
            
            if all_passed:
                perfect_videos.append(video)
        
        # Print per-test results
        print("\nüìà Test Results:")
        for test in test_names:
            passes = test_passes[test]
            rate = (passes / total_videos * 100) if total_videos > 0 else 0
            print(f"   {test}: {passes}/{total_videos} ({rate:.1f}%)")
        
        # Print perfect videos
        if perfect_videos:
            print(f"\nüéâ Videos with all tests passed ({len(perfect_videos)}):")
            for video in perfect_videos[:10]:  # Show first 10
                print(f"   ‚úÖ {video}")
            if len(perfect_videos) > 10:
                print(f"   ... and {len(perfect_videos) - 10} more")
        
        # Final score
        total_tests = total_videos * len(test_names)
        total_passes = sum(test_passes.values())
        overall_rate = (total_passes / total_tests * 100) if total_tests > 0 else 0
        
        print(f"\nüéØ OVERALL SCORE: {total_passes}/{total_tests} ({overall_rate:.1f}%)")
        
        if overall_rate == 100:
            print("üéâ PERFECT SCORE! All videos passed all tests!")
        elif overall_rate >= 90:
            print("üéä EXCELLENT! Most tests passed successfully.")
        elif overall_rate >= 70:
            print("‚ö†Ô∏è  GOOD! Some issues need attention.")
        else:
            print("‚ùå NEEDS WORK! Multiple issues detected.")


def main():
    """Main test function"""
    parser = argparse.ArgumentParser(description='Test existing caption files')
    parser.add_argument('directory', nargs='?', 
                       default='/Users/sarah.applebaum/Documents/FinalRenders/HDRP Lighting Fundamentals/Camtasia/mp4',
                       help='Directory containing caption files to test')
    parser.add_argument('--video', '-v', help='Test a specific video base name')
    
    args = parser.parse_args()
    
    directory = Path(args.directory)
    
    if not directory.exists():
        print(f"‚ùå Directory not found: {directory}")
        return 1
    
    print("üîß Initializing Caption Test...")
    
    test = ExistingCaptionTest()
    
    if args.video:
        # Test single video
        results = test.test_single_video(args.video, directory)
        
        if results:
            # Count passes
            passes = sum(1 for result in results.values() if result)
            total = len(results)
            
            print(f"\nüéØ FINAL SCORE: {passes}/{total} tests passed ({passes/total*100:.1f}%)")
            
            return 0 if passes == total else 1
        else:
            print("‚ùå Failed to test video")
            return 1
    else:
        # Test all videos
        test.test_all_videos(directory)
        return 0


if __name__ == "__main__":
    import sys
    sys.exit(main())
