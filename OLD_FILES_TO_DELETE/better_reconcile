#!/usr/bin/env python3
"""
VTT Reconciliation Script
Compares VTT subtitle file with raw text transcript and reconciles differences.
Maintains timecodes while respecting 42-character limit and 2-line maximum per cue.
Supports batch processing of folders.
"""

import re
import sys
import os
from pathlib import Path
from typing import List, Tuple, Optional, Dict
from difflib import SequenceMatcher


class VTTCue:
    """Represents a single VTT cue with timecode and text lines."""
    
    def __init__(self, timecode: str, lines: List[str]):
        self.timecode = timecode
        self.lines = lines
    
    def get_text(self) -> str:
        """Get all text from this cue as a single string."""
        return ' '.join(self.lines)
    
    def get_words(self) -> List[str]:
        """Extract all words from this cue."""
        return re.findall(r'\S+', self.get_text())
    
    def set_lines_from_words(self, words: List[str], max_chars: int = 42, max_lines: int = 2):
        """Reflow words into lines respecting character and line limits."""
        self.lines = reflow_words_to_lines(words, max_chars, max_lines)
    
    def can_fit_words(self, words: List[str], max_chars: int = 42, max_lines: int = 2) -> bool:
        """Check if given words can fit in this cue within limits."""
        lines = reflow_words_to_lines(words, max_chars, max_lines)
        return len(lines) <= max_lines


def parse_vtt(vtt_content: str) -> Tuple[str, List[VTTCue]]:
    """
    Parse VTT file and extract header and cues.
    Returns: (header, list of VTTCue objects)
    """
    lines = vtt_content.strip().split('\n')
    cues = []
    header_lines = []
    i = 0
    
    # Extract header (everything before first timecode)
    while i < len(lines):
        if '-->' in lines[i]:
            break
        header_lines.append(lines[i])
        i += 1
    
    header = '\n'.join(header_lines).strip()
    if not header:
        header = "WEBVTT"
    
    # Parse cues
    while i < len(lines):
        line = lines[i].strip()
        
        # Check if this is a timecode line
        if '-->' in line:
            timecode = line
            i += 1
            
            # Collect text lines for this cue
            text_lines = []
            while i < len(lines) and lines[i].strip():
                text_lines.append(lines[i].strip())
                i += 1
            
            if text_lines:
                cues.append(VTTCue(timecode, text_lines))
        
        i += 1
    
    return header, cues


def normalize_word(word: str) -> str:
    """
    Normalize word for comparison.
    Removes all non-alphanumeric characters and converts to lowercase.
    """
    return re.sub(r'[^\w]', '', word).lower()


def extract_words_with_positions(cues: List[VTTCue]) -> List[Tuple[str, int, int]]:
    """
    Extract words from VTT cues with their positions.
    Returns: List of (word, cue_index, word_index_in_cue)
    """
    words_with_pos = []
    for cue_idx, cue in enumerate(cues):
        cue_words = cue.get_words()
        for word_idx, word in enumerate(cue_words):
            words_with_pos.append((word, cue_idx, word_idx))
    return words_with_pos


def parse_raw_text(raw_text: str) -> List[str]:
    """Extract words from raw text."""
    return re.findall(r'\S+', raw_text)


def align_and_find_insertions(vtt_words: List[str], raw_words: List[str]) -> List[Tuple[int, str]]:
    """
    Compare VTT words with raw text words and find missing words.
    Returns: List of (insert_position, word) tuples
    """
    # Normalize for comparison
    vtt_normalized = [normalize_word(w) for w in vtt_words]
    raw_normalized = [normalize_word(w) for w in raw_words]
    
    # Use SequenceMatcher for alignment
    matcher = SequenceMatcher(None, vtt_normalized, raw_normalized)
    
    insertions = []
    
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if tag == 'insert':
            # Words present in raw text but missing in VTT
            for j in range(j1, j2):
                insertions.append((i1, raw_words[j]))
        elif tag == 'replace':
            # Handle replacements - prefer raw text version
            vtt_len = i2 - i1
            raw_len = j2 - j1
            
            if raw_len > vtt_len:
                # More words in raw text - insert the extras
                for j in range(j1 + vtt_len, j2):
                    insertions.append((i2, raw_words[j]))
    
    return insertions


def reflow_words_to_lines(words: List[str], max_chars: int = 42, max_lines: int = 2) -> List[str]:
    """
    Reflow words into lines, ensuring no line exceeds max_chars and total lines <= max_lines.
    Returns the lines that fit within max_lines constraint.
    
    Args:
        words: List of words to reflow
        max_chars: Maximum characters per line
        max_lines: Maximum number of lines allowed
    
    Returns:
        List of lines (up to max_lines)
    """
    if not words:
        return []
    
    lines = []
    current_line = []
    current_length = 0
    
    for word in words:
        word_length = len(word)
        
        # Calculate length if we add this word
        if current_line:
            # Need to account for space before word
            needed_length = current_length + 1 + word_length
        else:
            # First word in line, no space needed
            needed_length = word_length
        
        # Check if adding this word would exceed limit
        if current_line and needed_length > max_chars:
            # Save current line and start new one
            lines.append(' '.join(current_line))
            
            # Check if we've reached max lines
            if len(lines) >= max_lines:
                break
            
            current_line = [word]
            current_length = word_length
        else:
            # Add word to current line
            current_line.append(word)
            current_length = needed_length
    
    # Add the last line if we haven't exceeded max_lines
    if current_line and len(lines) < max_lines:
        lines.append(' '.join(current_line))
    
    return lines


def count_words_that_fit(words: List[str], max_chars: int = 42, max_lines: int = 2) -> int:
    """
    Count how many words from the list can fit within the constraints.
    
    Args:
        words: List of words to check
        max_chars: Maximum characters per line
        max_lines: Maximum number of lines
    
    Returns:
        Number of words that fit
    """
    if not words:
        return 0
    
    lines_used = 0
    current_line_length = 0
    words_fitted = 0
    
    for word in words:
        word_length = len(word)
        
        # Calculate length if we add this word
        if current_line_length > 0:
            needed_length = current_line_length + 1 + word_length
        else:
            needed_length = word_length
        
        # Check if adding this word would exceed line limit
        if current_line_length > 0 and needed_length > max_chars:
            # Need a new line
            lines_used += 1
            
            # Check if we've used all available lines
            if lines_used >= max_lines:
                break
            
            current_line_length = word_length
            words_fitted += 1
        else:
            # Add to current line
            current_line_length = needed_length
            words_fitted += 1
    
    return words_fitted


def insert_words_into_cues(
    cues: List[VTTCue], 
    words_with_pos: List[Tuple[str, int, int]], 
    insertions: List[Tuple[int, str]],
    max_chars: int = 42,
    max_lines: int = 2
) -> List[VTTCue]:
    """
    Insert missing words into appropriate cues, respecting line limits.
    If a cue would exceed max_lines, overflow words are pushed to next cue.
    """
    # Build a map of global word position to (cue_idx, local_word_idx)
    position_map = {}
    for global_idx, (word, cue_idx, local_idx) in enumerate(words_with_pos):
        position_map[global_idx] = (cue_idx, local_idx)
    
    # Group insertions by cue
    cue_insertions = {}  # cue_idx -> [(local_position, word)]
    
    for insert_pos, word in sorted(insertions):
        # Find which cue this insertion belongs to
        if insert_pos == 0:
            # Insert at beginning of first cue
            cue_idx = 0
            local_pos = 0
        elif insert_pos >= len(words_with_pos):
            # Insert at end of last cue
            cue_idx = len(cues) - 1
            local_pos = len(cues[cue_idx].get_words())
        else:
            # Insert before the word at insert_pos
            cue_idx, local_pos = position_map[insert_pos]
        
        if cue_idx not in cue_insertions:
            cue_insertions[cue_idx] = []
        cue_insertions[cue_idx].append((local_pos, word))
    
    # Create new cues with inserted words, handling overflow
    new_cues = []
    overflow_words = []
    
    for cue_idx, cue in enumerate(cues):
        # Start with any overflow from previous cue
        words = overflow_words.copy()
        overflow_words = []
        
        # Add original words from this cue
        original_words = cue.get_words()
        
        # If this cue has insertions, merge them in
        if cue_idx in cue_insertions:
            # Sort insertions by position (reverse order for correct insertion)
            insertions_for_cue = sorted(cue_insertions[cue_idx], reverse=True)
            
            for local_pos, word in insertions_for_cue:
                original_words.insert(local_pos, word)
        
        words.extend(original_words)
        
        # Check how many words can fit in this cue
        words_that_fit = count_words_that_fit(words, max_chars, max_lines)
        
        # Split words into what fits and what overflows
        cue_words = words[:words_that_fit]
        overflow_words = words[words_that_fit:]
        
        # Create new cue with words that fit
        if cue_words:
            new_cue = VTTCue(cue.timecode, [])
            new_cue.set_lines_from_words(cue_words, max_chars, max_lines)
            new_cues.append(new_cue)
    
    # Handle any remaining overflow words at the end
    if overflow_words and new_cues:
        # Append overflow to the last cue's timecode
        last_cue = new_cues[-1]
        
        # Create additional cue(s) for overflow using last timecode
        # This is a fallback - ideally subtitles should be timed properly
        remaining = overflow_words
        while remaining:
            words_that_fit = count_words_that_fit(remaining, max_chars, max_lines)
            if words_that_fit == 0:
                # Safety: if even one word doesn't fit, force it
                words_that_fit = 1
            
            chunk = remaining[:words_that_fit]
            remaining = remaining[words_that_fit:]
            
            overflow_cue = VTTCue(last_cue.timecode, [])
            overflow_cue.set_lines_from_words(chunk, max_chars, max_lines)
            new_cues.append(overflow_cue)
    
    return new_cues


def build_vtt_output(header: str, cues: List[VTTCue]) -> str:
    """Build final VTT file content from header and cues."""
    output = [header, ""]
    
    for cue in cues:
        output.append(cue.timecode)
        output.extend(cue.lines)
        output.append("")
    
    return '\n'.join(output)


def reconcile_vtt_with_transcript(
    vtt_content: str, 
    raw_text: str, 
    max_chars: int = 42,
    max_lines: int = 2,
    verbose: bool = True
) -> Tuple[str, int]:
    """
    Main reconciliation function.
    
    Args:
        vtt_content: Content of VTT file
        raw_text: Raw transcript text
        max_chars: Maximum characters per line (default: 42)
        max_lines: Maximum lines per cue (default: 2)
        verbose: Print detailed information
    
    Returns:
        Tuple of (Reconciled VTT content as string, number of insertions)
    """
    # Step 1: Parse VTT file
    header, cues = parse_vtt(vtt_content)
    
    if not cues:
        if verbose:
            print("  ⚠ Warning: No cues found in VTT file")
        return vtt_content, 0
    
    # Step 2: Extract words from VTT with position tracking
    words_with_pos = extract_words_with_positions(cues)
    vtt_words = [word for word, _, _ in words_with_pos]
    
    # Step 3: Parse raw text
    raw_words = parse_raw_text(raw_text)
    
    # Step 4: Find words missing in VTT
    insertions = align_and_find_insertions(vtt_words, raw_words)
    
    if not insertions:
        if verbose:
            print("  ✓ No missing words found")
        # Still reflow to ensure character and line limits
        for cue in cues:
            cue.set_lines_from_words(cue.get_words(), max_chars, max_lines)
        return build_vtt_output(header, cues), 0
    
    if verbose:
        print(f"  ✓ Found {len(insertions)} word(s) to insert")
    
    # Step 5: Insert missing words into appropriate cues
    new_cues = insert_words_into_cues(cues, words_with_pos, insertions, max_chars, max_lines)
    
    if verbose:
        # Count cues with line violations before reflow
        violations = sum(1 for cue in new_cues if len(cue.lines) > max_lines)
        if violations > 0:
            print(f"  ✓ Reflowed {violations} cue(s) to respect {max_lines}-line limit")
    
    # Step 6: Build final VTT output
    return build_vtt_output(header, new_cues), len(insertions)


def find_file_pairs(folder_path: str) -> Dict[str, Tuple[str, str]]:
    """
    Find matching VTT and TXT file pairs in a folder.
    
    Args:
        folder_path: Path to folder containing VTT and TXT files
    
    Returns:
        Dictionary mapping base name to (vtt_path, txt_path) tuple
    """
    folder = Path(folder_path)
    
    if not folder.exists():
        raise FileNotFoundError(f"Folder not found: {folder_path}")
    
    if not folder.is_dir():
        raise NotADirectoryError(f"Not a directory: {folder_path}")
    
    # Find all VTT files
    vtt_files = {}
    for vtt_file in folder.glob("*.vtt"):
        # Skip already corrected files
        if vtt_file.stem.endswith('_corrected') or vtt_file.stem.endswith('_reconciled'):
            continue
        base_name = vtt_file.stem
        vtt_files[base_name] = vtt_file
    
    # Find all TXT files
    txt_files = {}
    for txt_file in folder.glob("*.txt"):
        base_name = txt_file.stem
        txt_files[base_name] = txt_file
    
    # Match pairs
    pairs = {}
    for base_name in vtt_files:
        if base_name in txt_files:
            pairs[base_name] = (str(vtt_files[base_name]), str(txt_files[base_name]))
    
    return pairs


def process_folder(folder_path: str, max_chars: int = 42, max_lines: int = 2) -> None:
    """
    Process all VTT and TXT pairs in a folder.
    
    Args:
        folder_path: Path to folder containing files
        max_chars: Maximum characters per line
        max_lines: Maximum lines per cue
    """
    print(f"{'='*70}")
    print(f"VTT Reconciliation - Batch Processing")
    print(f"{'='*70}")
    print(f"Folder: {folder_path}")
    print(f"Max characters per line: {max_chars}")
    print(f"Max lines per subtitle: {max_lines}")
    print()
    
    # Find file pairs
    try:
        pairs = find_file_pairs(folder_path)
    except Exception as e:
        print(f"❌ Error finding file pairs: {e}")
        sys.exit(1)
    
    if not pairs:
        print("❌ No matching VTT/TXT file pairs found in folder")
        print("\nMake sure your files are named identically:")
        print("  ✓ example.vtt + example.txt")
        print("  ✓ video1.vtt + video1.txt")
        sys.exit(1)
    
    print(f"Found {len(pairs)} file pair(s) to process:")
    for base_name in sorted(pairs.keys()):
        print(f"  • {base_name}")
    print()
    
    # Process each pair
    results = []
    total_insertions = 0
    
    for idx, (base_name, (vtt_path, txt_path)) in enumerate(sorted(pairs.items()), 1):
        print(f"[{idx}/{len(pairs)}] Processing: {base_name}")
        
        try:
            # Read files
            with open(vtt_path, 'r', encoding='utf-8') as f:
                vtt_content = f.read()
            
            with open(txt_path, 'r', encoding='utf-8') as f:
                raw_text = f.read()
            
            # Reconcile
            reconciled_vtt, num_insertions = reconcile_vtt_with_transcript(
                vtt_content, 
                raw_text, 
                max_chars,
                max_lines,
                verbose=True
            )
            
            total_insertions += num_insertions
            
            # Generate output path
            vtt_file = Path(vtt_path)
            output_path = vtt_file.parent / f"{vtt_file.stem}_corrected.vtt"
            
            # Write output
            with open(output_path, 'w', encoding='utf-8') as f:
                f.write(reconciled_vtt)
            
            print(f"  ✓ Saved: {output_path.name}")
            results.append((base_name, 'success', num_insertions, output_path.name))
            
        except Exception as e:
            print(f"  ❌ Error: {e}")
            results.append((base_name, 'failed', 0, str(e)))
        
        print()
    
    # Print summary
    print(f"{'='*70}")
    print("SUMMARY")
    print(f"{'='*70}")
    
    successful = sum(1 for r in results if r[1] == 'success')
    failed = sum(1 for r in results if r[1] == 'failed')
    
    print(f"Total files processed: {len(results)}")
    print(f"Successful: {successful}")
    print(f"Failed: {failed}")
    print(f"Total words inserted: {total_insertions}")
    print()
    
    if successful > 0:
        print("Successfully processed files:")
        for base_name, status, insertions, output in results:
            if status == 'success':
                print(f"  ✓ {output} ({insertions} insertion(s))")
    
    if failed > 0:
        print("\nFailed files:")
        for base_name, status, _, error in results:
            if status == 'failed':
                print(f"  ❌ {base_name}: {error}")
    
    print(f"{'='*70}")


def process_single_file(vtt_file: str, txt_file: str, max_chars: int = 42, max_lines: int = 2) -> None:
    """
    Process a single VTT and TXT file pair.
    
    Args:
        vtt_file: Path to VTT file
        txt_file: Path to TXT file
        max_chars: Maximum characters per line
        max_lines: Maximum lines per cue
    """
    print(f"{'='*70}")
    print(f"VTT Reconciliation - Single File Processing")
    print(f"{'='*70}")
    print(f"VTT file: {vtt_file}")
    print(f"TXT file: {txt_file}")
    print(f"Max characters per line: {max_chars}")
    print(f"Max lines per subtitle: {max_lines}")
    print()
    
    try:
        # Read input files
        with open(vtt_file, 'r', encoding='utf-8') as f:
            vtt_content = f.read()
        
        with open(txt_file, 'r', encoding='utf-8') as f:
            raw_text = f.read()
        
        print("Processing...")
        print()
        
        # Reconcile
        reconciled_vtt, num_insertions = reconcile_vtt_with_transcript(
            vtt_content, 
            raw_text, 
            max_chars,
            max_lines,
            verbose=True
        )
        
        # Generate output filename
        vtt_path = Path(vtt_file)
        output_file = vtt_path.parent / f"{vtt_path.stem}_corrected.vtt"
        
        # Write output
        with open(output_file, 'w', encoding='utf-8') as f:
            f.write(reconciled_vtt)
        
        print()
        print(f"{'='*70}")
        print(f"✓ SUCCESS")
        print(f"{'='*70}")
        print(f"Words inserted: {num_insertions}")
        print(f"Output saved to: {output_file}")
        print(f"{'='*70}")
        
    except FileNotFoundError as e:
        print(f"❌ Error: File not found - {e}")
        sys.exit(1)
    except Exception as e:
        print(f"❌ Error: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)


def main():
    """Main entry point for command-line usage."""
    if len(sys.argv) < 2:
        print("Usage:")
        print("  Batch mode (folder):  python reconcile_vtt.py <folder_path>")
        print("  Single file mode:     python reconcile_vtt.py <vtt_file> <txt_file>")
        print()
        print("Batch Mode:")
        print("  Processes all matching VTT/TXT pairs in a folder")
        print("  Files must have identical names (e.g., video1.vtt + video1.txt)")
        print("  Output: [OriginalName]_corrected.vtt")
        print()
        print("Single File Mode:")
        print("  Processes one VTT and TXT file pair")
        print("  Output: [OriginalName]_corrected.vtt")
        print()
        print("Options:")
        print("  --max-chars N     Set maximum characters per line (default: 42)")
        print("  --max-lines N     Set maximum lines per subtitle (default: 2)")
        sys.exit(1)
    
    # Parse arguments
    max_chars = 42
    max_lines = 2
    args = sys.argv[1:]
    
    # Parse --max-chars
    if '--max-chars' in args:
        idx = args.index('--max-chars')
        if idx + 1 < len(args):
            try:
                max_chars = int(args[idx + 1])
                args.pop(idx)  # Remove --max-chars
                args.pop(idx)  # Remove the number
            except (ValueError, IndexError):
                print("Error: --max-chars requires a number")
                sys.exit(1)
    
    # Parse --max-lines
    if '--max-lines' in args:
        idx = args.index('--max-lines')
        if idx + 1 < len(args):
            try:
                max_lines = int(args[idx + 1])
                args.pop(idx)  # Remove --max-lines
                args.pop(idx)  # Remove the number
            except (ValueError, IndexError):
                print("Error: --max-lines requires a number")
                sys.exit(1)
    
    # Determine mode based on remaining arguments
    if len(args) == 1:
        # Batch mode - folder processing
        folder_path = args[0]
        if not os.path.isdir(folder_path):
            print(f"Error: '{folder_path}' is not a directory")
            print("For single file processing, provide both VTT and TXT files:")
            print(f"  python {sys.argv[0]} <vtt_file> <txt_file>")
            sys.exit(1)
        
        process_folder(folder_path, max_chars, max_lines)
        
    elif len(args) == 2:
        # Single file mode
        vtt_file = args[0]
        txt_file = args[1]
        
        if not os.path.isfile(vtt_file):
            print(f"Error: VTT file not found: {vtt_file}")
            sys.exit(1)
        
        if not os.path.isfile(txt_file):
            print(f"Error: TXT file not found: {txt_file}")
            sys.exit(1)
        
        process_single_file(vtt_file, txt_file, max_chars, max_lines)
        
    else:
        print("Error: Invalid number of arguments")
        print("Use one of:")
        print(f"  python {sys.argv[0]} <folder_path>")
        print(f"  python {sys.argv[0]} <vtt_file> <txt_file>")
        sys.exit(1)


if __name__ == "__main__":
    main()
